#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START EXP MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END EXP MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
controller Controller = controller();
motor Left = motor(PORT1, false);

motor Front = motor(PORT3, false);

motor Right = motor(PORT5, true);

motor Back = motor(PORT8, true);




// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;
#pragma endregion VEXcode Generated Robot Configuration
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       FiveSixEP                                                 */
/*    Created:      4/1/23                                                    */
/*    Description:  Field Oriented X Drive                                    */
/*                                                                            */
/*----------------------------------------------------------------------------*/

// Include the VEX Library
#include "vex.h"
  
// Allows for easier use of the VEX Library
using namespace vex;

boolean fieldOriented = true;

double axisLR, axisFB, axisRot, leftMotor, leftPower, rightMotor, rightPower, frontMotor, frontPower, backMotor, backPower, gyroHeadingDeg, gyroHeadingRad, velocityFB, velocityLR, minValue, maxValue, normFactor;

int main() 
{

  // Main Drive
  while(true) 
  {
    
    // Main Driving Calculation

    // Get current heading from gyro
    if (fieldOriented) {gyroHeadingDeg = BrainInertial.heading() + 45;}
    else {gyroHeadingDeg = 45;}

    // Convert to radians
    gyroHeadingRad = gyroHeadingDeg * (3.14159/180);
    
    // Get controller values
    axisFB = Controller.Axis3.position();
    axisLR = Controller.Axis4.position();
    axisRot = Controller.Axis1.position();

    // Calculate robot velocity with current direction and joystick values
    velocityFB = cos(gyroHeadingRad)*axisFB + sin(gyroHeadingRad)*axisLR; velocityLR = cos(gyroHeadingRad)*axisLR - sin(gyroHeadingRad)*axisFB;

    // Apply rotation axis
    leftMotor = velocityFB+axisRot;
    rightMotor = velocityFB-axisRot;
    frontMotor = velocityLR+axisRot;
    backMotor = velocityLR-axisRot;

    // Normalize rotation values
    if (leftMotor > 1 || rightMotor > 1 || frontMotor > 1 || backMotor > 1 || leftMotor < -1 || rightMotor < -1 || frontMotor < -1 || backMotor < -1)
    {
      if (leftMotor > 0) {maxValue = leftMotor;} 
      else {maxValue = -leftMotor;}

      if (rightMotor > maxValue) {maxValue = rightMotor;} 
      else if (rightMotor < -maxValue) {maxValue = -rightMotor;}

      if (frontMotor > maxValue) {maxValue = frontMotor;} 
      else if (frontMotor < -maxValue) {maxValue = -frontMotor;}

      if (backMotor > maxValue) {maxValue = backMotor;} 
      else if (backMotor < -maxValue) {maxValue = -backMotor;}

      normFactor = 1 / maxValue;

      // Convert to percentage
      leftPower = leftMotor * normFactor * 100;
      rightPower = rightMotor * normFactor * 100;
      frontPower = frontMotor * normFactor * 100;
      backPower = backMotor * normFactor * 100;
    }

    //Set speeds of motors
    Left.spin(forward);
    Right.spin(forward);
    Front.spin(forward);
    Back.spin(forward);
    Left.setVelocity(leftMotor, percent);
    Right.setVelocity(rightMotor, percent);
    Front.setVelocity(frontMotor,percent);
    Back.setVelocity(backMotor,percent);
    
    // Turn of field oriented control if needed
    if (Controller.ButtonA.pressing()) {fieldOriented = true;}
    if (Controller.ButtonB.pressing()) {fieldOriented = false;}

    wait(5,msec);
  };
  return 0;
}
