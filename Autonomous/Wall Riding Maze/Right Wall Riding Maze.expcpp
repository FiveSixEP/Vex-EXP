#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START EXP MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END EXP MACROS


// Robot configuration code.
inertial BrainInertial = inertial();
motor leftMotorA = motor(PORT1, false);
motor leftMotorB = motor(PORT6, false);
motor_group LeftDriveSmart = motor_group(leftMotorA, leftMotorB);
motor rightMotorA = motor(PORT10, true);
motor rightMotorB = motor(PORT5, true);
motor_group RightDriveSmart = motor_group(rightMotorA, rightMotorB);
smartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, BrainInertial, 219.44, 320, 40, mm, 1);

distance RightDistance = distance(PORT7);
bumper FrontBumper = bumper(Brain.ThreeWirePort.A);

void calibrateDrivetrain() {
  wait(200, msec);
  Brain.Screen.print("Calibrating");
  Brain.Screen.newLine();
  Brain.Screen.print("Inertial");
  BrainInertial.calibrate();
  while (BrainInertial.isCalibrating()) {
    wait(25, msec);
  }

  // Clears the screen and returns the cursor to row 1, column 1.
  Brain.Screen.clearScreen();
  Brain.Screen.setCursor(1, 1);
}
#pragma endregion VEXcode Generated Robot Configuration
// Include the VEX Library
#include "vex.h"

// Allows for easier use of the VEX Library
using namespace vex;

// Variable declaration
double currentHeading; // stores the current heading of the robot
double distanceFromWall = 300; // represents the minimum distance a wall 
//must be from the sensor in order to be detected as an open wall.
double drivetrainVelocity = 100; // Drive speed in percent
double drivetrainTurnVelocity = 100; // Turn speed in percent
double drivetrainClearanceDistance = 150; // Distance from sensor to back of robot in mm

int main() {
  // Calibrate the Drivetrain
  calibrateDrivetrain();

  // post event registration

  // set default print color to black
  printf("\033[30m");

  // Wait for ADI sensors to initialize
  wait(100, msec);

  // Set drivetrain velocity and stopping mode
  Drivetrain.setDriveVelocity(drivetrainVelocity, percent);
  Drivetrain.setTurnVelocity(drivetrainTurnVelocity, percent);
  Drivetrain.setStopping(coast);

  // Variable initialization
  currentHeading = BrainInertial.heading(degrees);
  
  // Start forever loop
  while (true) {
    // Keep driving forward until a wall or bumper is detected
    while (!(FrontBumper.pressing() || RightDistance.objectDistance(mm) > distanceFromWall)) {
      Drivetrain.drive(forward);
      // Turn to the current heading if necessary
      if (currentHeading != Drivetrain.heading()) {
        Drivetrain.turnToHeading(currentHeading, degrees, true);
      }
      wait(5, msec);
    }

    // Stop driving when a wall or bumper is detected
    Drivetrain.stop();

    if (RightDistance.objectDistance(mm) > distanceFromWall) {
      // If no wall is detected on the right, drive forward for clearance
      Drivetrain.driveFor(forward, drivetrainClearanceDistance, mm, true);
      // Turn 90 degrees to the right
      currentHeading += 90.0;
      Drivetrain.turnToHeading(currentHeading, degrees, true);
      // Keep driving until a wall is detected or bumper is pressed
      while (!(RightDistance.objectDistance(mm) < distanceFromWall || FrontBumper.pressing())) {
        Drivetrain.drive(forward);
        wait(5, msec);
      }
      // Stop driving
      Drivetrain.stop();
    } else {
      // A wall is detected, assume the bumper is pressed, and turn 90 degrees to the left
      currentHeading -= 90.0;
      Drivetrain.turnToHeading(currentHeading, degrees, true);
    }
    wait(5, msec);
  }
}
